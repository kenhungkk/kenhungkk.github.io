{
  "hash": "ecd463abd3d5d2a7a53fea3fd729ee87",
  "result": {
    "markdown": "---\ntitle: Playing with Bayes and RStan\ndescription: First time pretending to be a Bayesian, and trying RStan.\nauthor: Kenneth Hung\ndate: 2020-09-25\ncategories:\n  - statistical computing\nexecute: \n  freeze: true\n---\n\n\nI did not really much statistical training in my undergrad days, and my knowledge of statistics is pretty much confined to whatever grad level statistics classes Berkeley offered --- 99% of those was frequentist --- so I lack the Bayesian exposure that most statistics undergrad would have received. So when something slightly Bayesian (does empirical Bayes count?) showed up, I decided to teach myself using @gelman2013bayesian.\n\nIt is hard to learn something new without any examples, and I happen to stumble upon this tweet:\n\n<blockquote class=\"twitter-tweet tw-align-center\"><p lang=\"en\" dir=\"ltr\">Trend line can be misleading, and there are good years too. But certainly it looks like bad years had become worse. Just curious, where can I find the data itself for educational purposes?</p>&mdash; Kenneth Hung (@kenhungkk) <a href=\"https://twitter.com/kenhungkk/status/1302973968748478464?ref_src=twsrc%5Etfw\">September 7, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nThe data itself is [here](https://www.fire.ca.gov/media/11397/fires-acres-all-agencies-thru-2018.pdf) and I got to [learn how to handle PDFs](https://blog.az.sg/posts/reading-pdfs-in-r/) with `pdftools` as well.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(pdftools)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing poppler version 22.08.0\n```\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rstan)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: StanHeaders\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nrstan (Version 2.21.5, GitRev: 2e1f913d3ca3)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFor execution on a local, multicore CPU with excess RAM we recommend calling\noptions(mc.cores = parallel::detectCores()).\nTo avoid recompilation of unchanged Stan programs, we recommend calling\nrstan_options(auto_write = TRUE)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'rstan'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:tidyr':\n\n    extract\n```\n:::\n\n```{.r .cell-code}\nlibrary(foreach)\nlibrary(doParallel)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: iterators\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: parallel\n```\n:::\n\n```{.r .cell-code}\ntheme_set(theme_minimal())\noptions(mc.cores = parallel::detectCores())\nregisterDoParallel(cores = parallel::detectCores())\n\nraw.text <- pdf_text(\n  'https://www.fire.ca.gov/media/11397/fires-acres-all-agencies-thru-2018.pdf'\n) %>%\n  str_split(\"\\n\") %>%\n  unlist()\n\ndata <- raw.text[4:35] %>%\n  as_tibble(.name_repair = \"unique\") %>%\n  mutate(\n    full.year = str_sub(value, end = 6), acres = str_sub(value, start = 132)\n  ) %>%\n  select(-value) %>%\n  mutate_all(str_trim) %>%\n  mutate_all(str_replace_all, \",\", \"\") %>%\n  mutate_all(as.numeric) %>%\n  mutate(year = full.year - min(full.year))\nN <- nrow(data)\n\nggplot(data) + geom_line(aes(x = full.year, y = acres))\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nLike I said in the tweet, a linear fit seems off.\n\nUsing the default priors, I ran a Bayesian linear regression. I have to say, seeing the chains running and utilizing my new laptop's computation power was very exciting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.stan <- \"\ndata {\n  int<lower=0> N;\n  vector[N] x;\n  vector[N] y;\n}\nparameters {\n  real alpha;\n  real beta;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(alpha + beta * x, sigma);\n}\n\"\n\nfit <- stan(\n  model_code = model.stan,\n  data = list(N = N, x = data$year, y = data$acres),\n  iter = 5000\n)\n\nsummary(fit)$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             mean      se_mean           sd        2.5%         25%         50%\nalpha 240006.8645 2.539418e+03 1.551917e+05 -68013.3021 137908.1746 239675.9123\nbeta   25350.8491 1.403148e+02 8.616489e+03   8211.8978  19674.1566  25370.7932\nsigma 447205.8818 8.786446e+02 6.045076e+04 348075.7837 404490.9808 440528.5524\nlp__    -418.5083 2.070267e-02 1.255783e+00   -421.7157   -419.1005   -418.1869\n              75%       97.5%    n_eff      Rhat\nalpha 344199.6611 552040.4477 3734.813 0.9997395\nbeta   31137.5510  42277.3893 3770.976 0.9999660\nsigma 481952.3839 586203.5716 4733.442 1.0006884\nlp__    -417.5703   -417.0499 3679.393 1.0005287\n```\n:::\n:::\n\n\nSince all Bayesians do is do posterior draws, I don't find it hard to understand the result. But what matters the most to me is that the data is fit well. As BDA would suggest, I should do a posterior predictive check, specifically something that would demonstrate my suspicion that linear model isn't a good fit. By looking at the time series, I would guess that there are fewer positive residuals than negative ones. So I used the proportion of positive residuals after OLS as the test statistic. Embarrassingly it took me a long time to realize how to do a posterior predictive check for regression, the most basic example in Chapter 14 surprisingly did not emphasize this part.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npost <- extract(fit)\npost.pred.stat <- foreach(\n  alpha = post$alpha,\n  beta = post$beta,\n  sigma = post$sigma,\n  .combine = \"c\"\n) %dopar% {\n  y.rep <- alpha + beta * data$year + sigma * rnorm(N)\n  residual.rep <- residuals(lm(y.rep ~ data$year))\n  mean(residual.rep > 0)\n}\n\nresidual <- residuals(lm(acres ~ year, data = data))\nobs.stat <- mean(residual > 0)\n\nggplot() +\n  geom_histogram(\n    aes(x = post.pred.stat), alpha = 0.5, binwidth = 1 / nrow(data)\n  ) +\n  geom_vline(xintercept = obs.stat)\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nIt looks like we have way too few positive residuals and I should probably use a log-linear model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.stan <- \"\ndata {\n  int<lower=0> N;\n  vector[N] x;\n  vector[N] y;\n}\nparameters {\n  real alpha;\n  real beta;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(alpha + beta * x, sigma);\n}\n\"\n\nfit <- stan(\n  model_code = model.stan,\n  data = list(N = N, x = data$year, y = log(data$acres)),\n  iter = 5000\n)\n\nsummary(fit)$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             mean      se_mean         sd         2.5%         25%        50%\nalpha 12.41908326 0.0043276351 0.27139695  11.89028656 12.23991697 12.4138605\nbeta   0.04168707 0.0002393191 0.01502463   0.01160145  0.03212815  0.0418301\nsigma  0.76934629 0.0015107737 0.10299026   0.60040099  0.69765468  0.7585032\nlp__  -7.16169509 0.0235539924 1.33780557 -10.65728017 -7.71969447 -6.8090985\n              75%       97.5%    n_eff     Rhat\nalpha 12.59937319 12.95217175 3932.861 1.000875\nbeta   0.05154402  0.07100689 3941.421 1.000715\nsigma  0.82879300  0.99799036 4647.222 1.000257\nlp__  -6.20961693 -5.68965437 3225.945 1.000177\n```\n:::\n:::\n\n\nAnd we perform the same check to see if the residuals are symmetric.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npost <- extract(fit)\npost.pred.stat <- foreach(\n  alpha = post$alpha,\n  beta = post$beta,\n  sigma = post$sigma,\n  .combine = \"c\"\n) %dopar% {\n  y.rep <- alpha + beta * data$year + sigma * rnorm(N)\n  residual.rep <- residuals(lm(y.rep ~ data$year))\n  mean(residual.rep > 0)\n}\n\nresidual <- residuals(lm(log(acres) ~ year, data = data))\nobs.stat <- mean(residual > 0)\n\nggplot() +\n  geom_histogram(\n    aes(x = post.pred.stat), alpha = 0.5, binwidth = 1 / nrow(data)\n  ) +\n  geom_vline(xintercept = obs.stat)\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nMuch better! Of course the model is not going to be correct, but we just need to keep checking for statistics that we care about. One idea I had is the number of times a new record is set. From the time series, it is 5 --- we will count the very first year, not that it really matters. I thought this may be revealing if there is a lot of autocorrelation in the time series --- for example, the more acres are burnt the previous year, the less there is to burn the year after.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npost <- extract(fit)\npost.pred.stat <- foreach(\n  alpha = post$alpha,\n  beta = post$beta,\n  sigma = post$sigma,\n  .combine = \"c\"\n) %dopar% {\n  y.rep <- alpha + beta * data$year + sigma * rnorm(N)\n  sum(y.rep == cummax(y.rep))\n}\n\nobs.stat <- sum(data$acres == cummax(data$acres))\n\nggplot() +\n  geom_histogram(\n    aes(x = post.pred.stat), alpha = 0.5, binwidth = 1\n  ) +\n  geom_vline(xintercept = obs.stat)\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nNot too bad! For both model it looks like the slope is positive. There are many other data that would have been relevant to this analysis, such as the rainfall the year before and other climate data. There are also more sophisticated things such as Bayesian ARIMA that I could do (but I don't know how), but hey, there are only 32 points in this dataset.\n",
    "supporting": [
      "cal-fire_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}