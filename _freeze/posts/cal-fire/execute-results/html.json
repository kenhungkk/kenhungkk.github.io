{
  "hash": "5271af6d56c8e37898180176bc08cfdc",
  "result": {
    "markdown": "---\ntitle: Playing with Bayes and RStan\ndescription: First time pretending to be a Bayesian, and trying RStan.\nauthor: Kenneth Hung\ndate: 2020-09-25\ncategories:\n  - statistical computing\nexecute: \n  freeze: true\n---\n\n\nI did not really much statistical training in my undergrad days, and my knowledge of statistics is pretty much confined to whatever grad level statistics classes Berkeley offered --- 99% of those was frequentist --- so I lack the Bayesian exposure that most statistics undergrad would have received. So when something slightly Bayesian (does empirical Bayes count?) showed up, I decided to teach myself using Gelman et al.'s Bayesian Data Analysis (BDA).\n\nIt is hard to learn something new without any examples, and I happen to stumble upon this tweet:\n\n<blockquote class=\"twitter-tweet tw-align-center\"><p lang=\"en\" dir=\"ltr\">Trend line can be misleading, and there are good years too. But certainly it looks like bad years had become worse. Just curious, where can I find the data itself for educational purposes?</p>&mdash; Kenneth Hung (@kenhungkk) <a href=\"https://twitter.com/kenhungkk/status/1302973968748478464?ref_src=twsrc%5Etfw\">September 7, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nThe data itself is [here](https://www.fire.ca.gov/media/11397/fires-acres-all-agencies-thru-2018.pdf) and I got to [learn how to handle PDFs](https://blog.az.sg/posts/reading-pdfs-in-r/) with `pdftools` as well.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(pdftools)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing poppler version 22.06.0\n```\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rstan)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: StanHeaders\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nrstan (Version 2.21.5, GitRev: 2e1f913d3ca3)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFor execution on a local, multicore CPU with excess RAM we recommend calling\noptions(mc.cores = parallel::detectCores()).\nTo avoid recompilation of unchanged Stan programs, we recommend calling\nrstan_options(auto_write = TRUE)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'rstan'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:tidyr':\n\n    extract\n```\n:::\n\n```{.r .cell-code}\nlibrary(foreach)\nlibrary(doParallel)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: iterators\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: parallel\n```\n:::\n\n```{.r .cell-code}\ntheme_set(theme_minimal())\noptions(mc.cores = parallel::detectCores())\nregisterDoParallel(cores = parallel::detectCores())\n\nraw.text <- pdf_text(\n  'https://www.fire.ca.gov/media/11397/fires-acres-all-agencies-thru-2018.pdf'\n) %>%\n  str_split(\"\\n\") %>%\n  unlist()\n\ndata <- raw.text[4:35] %>%\n  as_tibble(.name_repair = \"unique\") %>%\n  mutate(\n    full.year = str_sub(value, end = 6), acres = str_sub(value, start = 132)\n  ) %>%\n  select(-value) %>%\n  mutate_all(str_trim) %>%\n  mutate_all(str_replace_all, \",\", \"\") %>%\n  mutate_all(as.numeric) %>%\n  mutate(year = full.year - min(full.year))\nN <- nrow(data)\n\nggplot(data) + geom_line(aes(x = full.year, y = acres))\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nLike I said in the tweet, a linear fit seems off.\n\nUsing the default priors, I ran a Bayesian linear regression. I have to say, seeing the chains running and utilizing my new laptop's computation power was very exciting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.stan <- \"\ndata {\n  int<lower=0> N;\n  vector[N] x;\n  vector[N] y;\n}\nparameters {\n  real alpha;\n  real beta;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(alpha + beta * x, sigma);\n}\n\"\n\nfit <- stan(\n  model_code = model.stan,\n  data = list(N = N, x = data$year, y = data$acres),\n  iter = 5000\n)\n\nsummary(fit)$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             mean      se_mean           sd        2.5%       25%         50%\nalpha 233861.6416 2.418253e+03 1.505192e+05 -56282.8026 133276.65 234057.1686\nbeta   25712.3024 1.386032e+02 8.440824e+03   8960.8308  20128.12  25641.7003\nsigma 446620.0347 8.779346e+02 6.010647e+04 347284.0777 403933.76 440538.9490\nlp__    -418.4848 2.105554e-02 1.253319e+00   -421.6139   -419.06   -418.1599\n              75%       97.5%    n_eff     Rhat\nalpha 333661.8810 529685.6716 3874.187 1.000570\nbeta   31297.4117  42305.1190 3708.713 1.000377\nsigma 481793.5035 581284.2707 4687.251 1.000244\nlp__    -417.5718   -417.0565 3543.156 1.000716\n```\n:::\n:::\n\n\nSince all Bayesians do is do posterior draws, I don't find it hard to understand the result. But what matters the most to me is that the data is fit well. As BDA would suggest, I should do a posterior predictive check, specifically something that would demonstrate my suspicion that linear model isn't a good fit. By looking at the time series, I would guess that there are fewer positive residuals than negative ones. So I used the proportion of positive residuals after OLS as the test statistic. Embarrassingly it took me a long time to realize how to do a posterior predictive check for regression, the most basic example in Chapter 14 surprisingly did not emphasize this part.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npost <- extract(fit)\npost.pred.stat <- foreach(\n  alpha = post$alpha,\n  beta = post$beta,\n  sigma = post$sigma,\n  .combine = \"c\"\n) %dopar% {\n  y.rep <- alpha + beta * data$year + sigma * rnorm(N)\n  residual.rep <- residuals(lm(y.rep ~ data$year))\n  mean(residual.rep > 0)\n}\n\nresidual <- residuals(lm(acres ~ year, data = data))\nobs.stat <- mean(residual > 0)\n\nggplot() +\n  geom_histogram(\n    aes(x = post.pred.stat), alpha = 0.5, binwidth = 1 / nrow(data)\n  ) +\n  geom_vline(xintercept = obs.stat)\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nIt looks like we have way too few positive residuals and I should probably use a log-linear model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.stan <- \"\ndata {\n  int<lower=0> N;\n  vector[N] x;\n  vector[N] y;\n}\nparameters {\n  real alpha;\n  real beta;\n  real<lower=0> sigma;\n}\nmodel {\n  y ~ normal(alpha + beta * x, sigma);\n}\n\"\n\nfit <- stan(\n  model_code = model.stan,\n  data = list(N = N, x = data$year, y = log(data$acres)),\n  iter = 5000\n)\n\nsummary(fit)$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             mean      se_mean         sd         2.5%         25%         50%\nalpha 12.41468460 0.0045773388 0.27303403  11.88047622 12.23000357 12.41538394\nbeta   0.04188381 0.0002499936 0.01501446   0.01270324  0.03181958  0.04189893\nsigma  0.76954144 0.0014852081 0.10485453   0.59685152  0.69554526  0.75856354\nlp__  -7.15915278 0.0222561406 1.30575067 -10.58316010 -7.72086198 -6.82126935\n              75%       97.5%    n_eff     Rhat\nalpha 12.59478205 12.95319729 3558.012 1.001029\nbeta   0.05189791  0.07130844 3607.127 1.001190\nsigma  0.83173639  1.00139601 4984.250 1.000607\nlp__  -6.21397133 -5.68846914 3442.079 1.000834\n```\n:::\n:::\n\n\nAnd we perform the same check to see if the residuals are symmetric.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npost <- extract(fit)\npost.pred.stat <- foreach(\n  alpha = post$alpha,\n  beta = post$beta,\n  sigma = post$sigma,\n  .combine = \"c\"\n) %dopar% {\n  y.rep <- alpha + beta * data$year + sigma * rnorm(N)\n  residual.rep <- residuals(lm(y.rep ~ data$year))\n  mean(residual.rep > 0)\n}\n\nresidual <- residuals(lm(log(acres) ~ year, data = data))\nobs.stat <- mean(residual > 0)\n\nggplot() +\n  geom_histogram(\n    aes(x = post.pred.stat), alpha = 0.5, binwidth = 1 / nrow(data)\n  ) +\n  geom_vline(xintercept = obs.stat)\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nMuch better! Of course the model is not going to be correct, but we just need to keep checking for statistics that we care about. One idea I had is the number of times a new record is set. From the time series, it is 5 --- we will count the very first year, not that it really matters. I thought this may be revealing if there is a lot of autocorrelation in the time series --- for example, the more acres are burnt the previous year, the less there is to burn the year after.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npost <- extract(fit)\npost.pred.stat <- foreach(\n  alpha = post$alpha,\n  beta = post$beta,\n  sigma = post$sigma,\n  .combine = \"c\"\n) %dopar% {\n  y.rep <- alpha + beta * data$year + sigma * rnorm(N)\n  sum(y.rep == cummax(y.rep))\n}\n\nobs.stat <- sum(data$acres == cummax(data$acres))\n\nggplot() +\n  geom_histogram(\n    aes(x = post.pred.stat), alpha = 0.5, binwidth = 1\n  ) +\n  geom_vline(xintercept = obs.stat)\n```\n\n::: {.cell-output-display}\n![](cal-fire_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nNot too bad! For both model it looks like the slope is positive. There are many other data that would have been relevant to this analysis, such as the rainfall the year before and other climate data. There are also more sophisticated things such as Bayesian ARIMA that I could do (but I don't know how), but hey, there are only 32 points in this dataset.\n",
    "supporting": [
      "cal-fire_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}