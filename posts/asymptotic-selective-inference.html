<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kenneth Hung">
<meta name="dcterms.date" content="2017-04-10">
<meta name="description" content="Generalizing Lasso penalty to non-linear model, e.g.&nbsp;a binomial model.">

<title>L1-penalized likelihood asymptotics – Kenneth Hung</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d1b12f2568ecbe55642fee6aa00bd082.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Kenneth Hung</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../miscellaneous.html"> 
<span class="menu-text">Miscellaneous</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">L1-penalized likelihood asymptotics</h1>
  <div class="quarto-categories">
    <div class="quarto-category">selective inference</div>
  </div>
  </div>

<div>
  <div class="description">
    Generalizing Lasso penalty to non-linear model, e.g.&nbsp;a binomial model.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kenneth Hung </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 10, 2017</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Following a paper by <span class="citation" data-cites="lee2016exact">Lee et al. (<a href="#ref-lee2016exact" role="doc-biblioref">2016</a>)</span> on the correcting for the selection bias after lasso-based selection, a natural progression is to consider general penalized likelihood selections. In GLM, we are at least provided with a sufficient statistics, but this would not be the case in a more general likelihood setting, rendering the description of the selection event a lot more blurry.</p>
<p>Most specifically, the set up is as follows: we have a matrix <span class="math inline">\(X\)</span> consisting of <span class="math inline">\(n\)</span> row of covariates, <span class="math inline">\(Y\)</span> a vector consisting of all the responses. We assume the model, given by the log-likelihood below,</p>
<p><span class="math display">\[\sum_{i=1}^n \ell(\theta_n; Y_n, X_n).\]</span></p>
<p>Here we will not move into high-dimensional regime and thus assumes <span class="math inline">\(\theta_n\)</span> to have dimension <span class="math display">\[d\]</span>. Subsequently, we perform selection based on maximizing</p>
<p><span class="math display">\[\sum_{i=1}^n \ell(\theta_n; Y_n, X_n) - \lambda_n \|\theta_n\|_1,\]</span></p>
<p>with some tuning parameter <span class="math inline">\(\lambda_n\)</span>.</p>
<p>Around three weeks ago, Will and I came up with a way to tackle this problem — together with a non-exhaustive, non-optimized list of conditions needed. Unfortunately shortly after Will discovered a paper by <span class="citation" data-cites="taylor2017post">Taylor and Tibshirani (<a href="#ref-taylor2017post" role="doc-biblioref">2017</a>)</span> that arrived at an almost identical solution. While our result might no longer be groundbreaking, we hope that this post will provide a different perspective from Taylor and Tibshirani (2017), and assist anyone who happens to also be reading Taylor and Tibshirani (2017).</p>
<p>The problem has two main hurdles: - approximating the selection event in a reasonable yet theoretically valid manner; - choosing a test statistic with a nice asymptotic distribution.</p>
<p>We can make both decisions at once by considering the selection event. In GLM, with a sufficient statistic, the selection event will always be measurable with respect to this sufficient statistic. This measurability requirement results in fuzzy edges if we plot out the selection event based on a non-sufficient statistic.</p>
<p>We don’t have this sufficient statistic anymore in a general likelihood setting. Conventionally, both the score at a fixed parameter and the MLE are thought of as ‘asymptotically sufficient’ without a proper definition. Since we are looking into asymptotics anyways, these two statistic seems perfect for our use. A bonus is that their asymptotic distributions are well known.</p>
<p>Following classical asymptotic analysis as explained in van der Vaart (1998), we will assume that <span class="math inline">\(\theta_n = \theta_0 + \beta / \sqrt{n}\)</span> and thus converges to a <span class="math inline">\(\theta_0\)</span> that lies in the null hypothesis <span class="math inline">\(\Theta_0\)</span>. Other possible asymptotic regimes includes modifying the lasso minimization problem into a ‘non-centered’ lasso problem</p>
<p><span class="math display">\[\sum_{i=1}^n \ell(\theta_n; Y_n, X_n) - \lambda_n \|\theta_n - c_n\|_1,\]</span></p>
<p>but as it turns out the asymptotics will work out to the same solution anyways. For the lasso selection to not go trivial (always selecting certain variables, always not selecting certain variables, always making the correct selection), we also need to scale <span class="math inline">\(\lambda_n\)</span> as <span class="math inline">\(\lambda_n = \lambda \sqrt{n}\)</span>.</p>
<p>If we take the subgradient of the objective, normalized by <span class="math inline">\(1 / \sqrt{n}\)</span>, with respect to <span class="math inline">\(\theta_n\)</span>, we get something like</p>
<p><span class="math display">\[\frac{1}{\sqrt{n}} \sum_{i=1}^n \nabla \ell(\theta_n; Y_n, X_n) - \lambda s_n,\]</span></p>
<p>where <span class="math inline">\(s_n\)</span> is the subgradient of the <span class="math inline">\(L_1\)</span>-norm. This is the crucial step in Lee et al.&nbsp;(2013). For a the same set of variables selected and the same signs assigned, <span class="math inline">\(\lambda s_n\)</span> is a determined set. So what’s left is to relate the normalized score to the sufficient statistic.</p>
<p>In the asymptotic regime, the asymptotic sufficiency of score and the MLE means we can determine all the likelihood ratio, or equivalently, the entire sore function. From here we can approximate the score as a linear function at <span class="math inline">\(0\)</span> as</p>
<p><span class="math display">\[\frac{1}{\sqrt{n}} \sum_{i=1}^n \nabla \ell(\theta_n; Y_n, X_n) \approx \left[\frac{1}{n} \sum_{i=1}^n \nabla^2 \ell(0; Y_n, X_n)\right] \beta,\]</span></p>
<p>or as a linear function based at the MLE <span class="math inline">\(\hat{\theta}_n\)</span> (and hence <span class="math inline">\(\hat{\beta}\)</span>),</p>
<p><span class="math display">\[\frac{1}{\sqrt{n}} \sum_{i=1}^n \nabla \ell(\theta_n; Y_n, X_n) \approx \left[\frac{1}{n} \sum_{i=1}^n \nabla^2 \ell(\hat{\theta}_n; Y_n, X_n)\right] (\beta - \hat{\beta}).\]</span></p>
<p>We cannot however approximate this as a linear function at other points, such as the MLE restricted to the null hypothesis <span class="math inline">\(\Theta_0\)</span>, as it reduces the degree of freedom.</p>
<p>How do we choose between these two approximation? In finite sample, the ‘data’ might not lie close to <span class="math inline">\(0\)</span>, rendering the first approximation ill-motivated. The second one has an appeal that it moves with the data and tends to approximate the score function better locally near the MLE.</p>
<p>To be more concrete, we can have a look at this in practice. We generated 1000 samples of 100 points from a logistic model and ran <code>glmnet</code> on each of the 100 samples. The unrestricted MLE is used as the statistic and plotted below. Colors follow the signs and the variables selected.</p>
<div class="cell" data-layout-align="center">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">suppressPackageStartupMessages</span>({</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="fu">library</span>(foreach)</span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="fu">library</span>(doParallel)</span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="fu">library</span>(glmnet)</span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="fu">library</span>(ggplot2)</span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="fu">library</span>(dplyr)</span>
<span id="cb1-7"><a href="#cb1-7"></a>})</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="fu">theme_set</span>(<span class="fu">theme_minimal</span>())</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>Logistic <span class="ot">&lt;-</span> <span class="cf">function</span>(z) {</span>
<span id="cb1-12"><a href="#cb1-12"></a>  <span class="fu">return</span>(<span class="fu">exp</span>(z) <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(z)))</span>
<span id="cb1-13"><a href="#cb1-13"></a>}</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>SignSummary <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb1-16"><a href="#cb1-16"></a>  <span class="fu">return</span>(<span class="fu">paste</span>(<span class="fu">ifelse</span>(x <span class="sc">==</span> <span class="dv">0</span>, <span class="st">'0'</span>, <span class="fu">ifelse</span>(x <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="st">'+'</span>, <span class="st">'-'</span>)), <span class="at">collapse =</span> <span class="st">''</span>))</span>
<span id="cb1-17"><a href="#cb1-17"></a>}</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>HessianLogistic <span class="ot">&lt;-</span> <span class="cf">function</span>(x, theta) {</span>
<span id="cb1-20"><a href="#cb1-20"></a>  z <span class="ot">&lt;-</span> x <span class="sc">%*%</span> theta</span>
<span id="cb1-21"><a href="#cb1-21"></a>  psi<span class="fl">.2</span>nd <span class="ot">&lt;-</span> <span class="fu">exp</span>(z) <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(z))<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>  <span class="fu">return</span>(<span class="sc">-</span><span class="fu">t</span>(x) <span class="sc">%*%</span> (x <span class="sc">*</span> <span class="fu">as.vector</span>(psi<span class="fl">.2</span>nd)) <span class="sc">/</span> <span class="fu">nrow</span>(x))</span>
<span id="cb1-23"><a href="#cb1-23"></a>}</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>HessianGaussian <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb1-26"><a href="#cb1-26"></a>  <span class="fu">return</span>(<span class="sc">-</span><span class="fu">t</span>(x) <span class="sc">%*%</span> x <span class="sc">/</span> <span class="fu">nrow</span>(x))</span>
<span id="cb1-27"><a href="#cb1-27"></a>}</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a>GLMSim <span class="ot">&lt;-</span> <span class="cf">function</span>(theta, lambda, n, <span class="at">nRep =</span> <span class="dv">1000</span>, <span class="at">family =</span> <span class="st">'gaussian'</span>) {</span>
<span id="cb1-30"><a href="#cb1-30"></a>  <span class="co"># GLMSim produces a plot of the true selection events by simulation, with</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>  <span class="co"># approximation of the selection event based on Taylor expansion of the</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>  <span class="co"># log-likelihood at the true theta (dahsed) and the MLE (dotted)</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>  <span class="co">#</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>  <span class="co"># Args:</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>  <span class="co">#   theta: true parameter</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>  <span class="co">#   lambda: penalty parameter</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>  <span class="co">#   n: sample size</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>  <span class="co">#   nRep: number of points to be included</span></span>
<span id="cb1-39"><a href="#cb1-39"></a>  <span class="co">#   family: 'binomial' for logistic regression, 'gaussian' for linear</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>  <span class="co">#     regression</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>  <span class="co">#</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>  <span class="co"># Returns:</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>  <span class="co">#   A plot of the simulation</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>  <span class="fu">registerDoParallel</span>(<span class="at">cores =</span> <span class="dv">4</span>)</span>
<span id="cb1-45"><a href="#cb1-45"></a>  </span>
<span id="cb1-46"><a href="#cb1-46"></a>  <span class="co"># generates nRep possible sets of n observations</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>  x.cov.rt <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="sc">-</span><span class="fl">0.1</span>), <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.1</span>, <span class="dv">1</span>))</span>
<span id="cb1-48"><a href="#cb1-48"></a>  x <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(n <span class="sc">*</span> <span class="dv">2</span>), n, <span class="dv">2</span>) <span class="sc">%*%</span> x.cov.rt</span>
<span id="cb1-49"><a href="#cb1-49"></a>  <span class="cf">if</span> (family <span class="sc">==</span> <span class="st">'binomial'</span>) {</span>
<span id="cb1-50"><a href="#cb1-50"></a>    pr <span class="ot">&lt;-</span> <span class="fu">Logistic</span>(x <span class="sc">%*%</span> theta)</span>
<span id="cb1-51"><a href="#cb1-51"></a>    y <span class="ot">&lt;-</span> <span class="fu">foreach</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>nRep, <span class="at">.combine =</span> cbind) <span class="sc">%dopar%</span> {</span>
<span id="cb1-52"><a href="#cb1-52"></a>      <span class="fu">set.seed</span>(i)</span>
<span id="cb1-53"><a href="#cb1-53"></a>      <span class="fu">rbinom</span>(n, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">prob =</span> pr)</span>
<span id="cb1-54"><a href="#cb1-54"></a>    }</span>
<span id="cb1-55"><a href="#cb1-55"></a>  } <span class="cf">else</span> <span class="cf">if</span> (family <span class="sc">==</span> <span class="st">'gaussian'</span>) {</span>
<span id="cb1-56"><a href="#cb1-56"></a>    mu <span class="ot">&lt;-</span> x <span class="sc">%*%</span> theta</span>
<span id="cb1-57"><a href="#cb1-57"></a>    y <span class="ot">&lt;-</span> <span class="fu">foreach</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>nRep, <span class="at">.combine =</span> cbind) <span class="sc">%dopar%</span> {</span>
<span id="cb1-58"><a href="#cb1-58"></a>      <span class="fu">set.seed</span>(i)</span>
<span id="cb1-59"><a href="#cb1-59"></a>      <span class="fu">rnorm</span>(n, <span class="at">mean =</span> mu)</span>
<span id="cb1-60"><a href="#cb1-60"></a>    }</span>
<span id="cb1-61"><a href="#cb1-61"></a>  } <span class="cf">else</span> {</span>
<span id="cb1-62"><a href="#cb1-62"></a>    <span class="fu">stop</span>(<span class="st">'family is not binomial or gaussian'</span>)</span>
<span id="cb1-63"><a href="#cb1-63"></a>  }</span>
<span id="cb1-64"><a href="#cb1-64"></a>  </span>
<span id="cb1-65"><a href="#cb1-65"></a>  <span class="co"># runs glmnet to compute the selected variables at s = lambda</span></span>
<span id="cb1-66"><a href="#cb1-66"></a>  <span class="co"># computes mle as test statistic at s = 0</span></span>
<span id="cb1-67"><a href="#cb1-67"></a>  mle <span class="ot">&lt;-</span> <span class="fu">foreach</span>(<span class="at">i =</span> <span class="dv">1</span><span class="sc">:</span>nRep, <span class="at">.combine =</span> rbind, <span class="at">.packages =</span> <span class="st">"glmnet"</span>) <span class="sc">%dopar%</span> {</span>
<span id="cb1-68"><a href="#cb1-68"></a>    fit <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x, y[, i], <span class="at">family =</span> family, <span class="at">intercept =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-69"><a href="#cb1-69"></a>    coeff <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(</span>
<span id="cb1-70"><a href="#cb1-70"></a>      <span class="fu">coef</span>(</span>
<span id="cb1-71"><a href="#cb1-71"></a>        fit, <span class="at">s =</span> <span class="fu">c</span>(<span class="dv">0</span>, lambda), <span class="at">exact =</span> <span class="cn">TRUE</span>,</span>
<span id="cb1-72"><a href="#cb1-72"></a>        <span class="at">x =</span> x, <span class="at">y =</span> y[, i], <span class="at">family =</span> family,</span>
<span id="cb1-73"><a href="#cb1-73"></a>        <span class="at">intercept =</span> <span class="cn">FALSE</span></span>
<span id="cb1-74"><a href="#cb1-74"></a>      )</span>
<span id="cb1-75"><a href="#cb1-75"></a>    )</span>
<span id="cb1-76"><a href="#cb1-76"></a>    selection <span class="ot">&lt;-</span> <span class="fu">SignSummary</span>(coeff[<span class="sc">-</span><span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb1-77"><a href="#cb1-77"></a>    <span class="fu">data.frame</span>(</span>
<span id="cb1-78"><a href="#cb1-78"></a>      <span class="at">theta1 =</span> coeff[<span class="dv">2</span>, <span class="dv">1</span>], <span class="at">theta2 =</span> coeff[<span class="dv">3</span>, <span class="dv">1</span>],</span>
<span id="cb1-79"><a href="#cb1-79"></a>      <span class="at">selection =</span> selection</span>
<span id="cb1-80"><a href="#cb1-80"></a>    )</span>
<span id="cb1-81"><a href="#cb1-81"></a>  }</span>
<span id="cb1-82"><a href="#cb1-82"></a>  mle<span class="sc">$</span>selection <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(mle<span class="sc">$</span>selection)</span>
<span id="cb1-83"><a href="#cb1-83"></a>  </span>
<span id="cb1-84"><a href="#cb1-84"></a>  <span class="co"># computes the selection event based on the MLE at the first row</span></span>
<span id="cb1-85"><a href="#cb1-85"></a>  <span class="cf">if</span> (family <span class="sc">==</span> <span class="st">'binomial'</span>) {</span>
<span id="cb1-86"><a href="#cb1-86"></a>    hessian <span class="ot">&lt;-</span> <span class="fu">HessianLogistic</span>(x, <span class="fu">as.numeric</span>(mle[<span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]))</span>
<span id="cb1-87"><a href="#cb1-87"></a>  } <span class="cf">else</span> <span class="cf">if</span> (family <span class="sc">==</span> <span class="st">'gaussian'</span>) {</span>
<span id="cb1-88"><a href="#cb1-88"></a>    hessian <span class="ot">&lt;-</span> <span class="fu">HessianGaussian</span>(x)</span>
<span id="cb1-89"><a href="#cb1-89"></a>  }</span>
<span id="cb1-90"><a href="#cb1-90"></a>  </span>
<span id="cb1-91"><a href="#cb1-91"></a>  <span class="co"># computes the segments of the polyhedron for event '00'</span></span>
<span id="cb1-92"><a href="#cb1-92"></a>  zero.seg <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fu">t</span>(<span class="fu">solve</span>(hessian, <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>)))) <span class="sc">*</span></span>
<span id="cb1-93"><a href="#cb1-93"></a>    lambda</span>
<span id="cb1-94"><a href="#cb1-94"></a>  zero.seg <span class="ot">&lt;-</span> <span class="fu">cbind</span>(zero.seg, zero.seg[<span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>), ])</span>
<span id="cb1-95"><a href="#cb1-95"></a>  zero.seg <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(zero.seg)</span>
<span id="cb1-96"><a href="#cb1-96"></a>  <span class="co"># adds segment representing the other events</span></span>
<span id="cb1-97"><a href="#cb1-97"></a>  zero.seg <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb1-98"><a href="#cb1-98"></a>    zero.seg,</span>
<span id="cb1-99"><a href="#cb1-99"></a>    zero.seg <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">X3 =</span> X1, <span class="at">X4 =</span> <span class="fu">sign</span>(X2) <span class="sc">*</span> <span class="dv">10</span>),</span>
<span id="cb1-100"><a href="#cb1-100"></a>    zero.seg <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">X4 =</span> X2, <span class="at">X3 =</span> <span class="fu">sign</span>(X1) <span class="sc">*</span> <span class="dv">10</span>)</span>
<span id="cb1-101"><a href="#cb1-101"></a>  )</span>
<span id="cb1-102"><a href="#cb1-102"></a>  </span>
<span id="cb1-103"><a href="#cb1-103"></a>  <span class="co"># computes the selection event based on true theta</span></span>
<span id="cb1-104"><a href="#cb1-104"></a>  <span class="cf">if</span> (family <span class="sc">==</span> <span class="st">'binomial'</span>) {</span>
<span id="cb1-105"><a href="#cb1-105"></a>    true.hessian <span class="ot">&lt;-</span> <span class="fu">HessianLogistic</span>(x, theta)</span>
<span id="cb1-106"><a href="#cb1-106"></a>  } <span class="cf">else</span> <span class="cf">if</span> (family <span class="sc">==</span> <span class="st">'gaussian'</span>) {</span>
<span id="cb1-107"><a href="#cb1-107"></a>    true.hessian <span class="ot">&lt;-</span> hessian</span>
<span id="cb1-108"><a href="#cb1-108"></a>  }</span>
<span id="cb1-109"><a href="#cb1-109"></a>  </span>
<span id="cb1-110"><a href="#cb1-110"></a>  <span class="co"># computes the segments of the polyhedron for event '00'</span></span>
<span id="cb1-111"><a href="#cb1-111"></a>  true.zero.seg <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fu">t</span>(<span class="fu">solve</span>(true.hessian, <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>)))) <span class="sc">*</span></span>
<span id="cb1-112"><a href="#cb1-112"></a>    lambda</span>
<span id="cb1-113"><a href="#cb1-113"></a>  true.zero.seg <span class="ot">&lt;-</span> <span class="fu">cbind</span>(true.zero.seg, true.zero.seg[<span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>), ])</span>
<span id="cb1-114"><a href="#cb1-114"></a>  true.zero.seg <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(true.zero.seg)</span>
<span id="cb1-115"><a href="#cb1-115"></a>  <span class="co"># adds segment representing the other events</span></span>
<span id="cb1-116"><a href="#cb1-116"></a>  true.zero.seg <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb1-117"><a href="#cb1-117"></a>    true.zero.seg,</span>
<span id="cb1-118"><a href="#cb1-118"></a>    true.zero.seg <span class="sc">%&gt;%</span></span>
<span id="cb1-119"><a href="#cb1-119"></a>      dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">X3 =</span> X1, <span class="at">X4 =</span> <span class="fu">sign</span>(X2) <span class="sc">*</span> <span class="dv">10</span>),</span>
<span id="cb1-120"><a href="#cb1-120"></a>    true.zero.seg <span class="sc">%&gt;%</span></span>
<span id="cb1-121"><a href="#cb1-121"></a>      dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">X4 =</span> X2, <span class="at">X3 =</span> <span class="fu">sign</span>(X1) <span class="sc">*</span> <span class="dv">10</span>)</span>
<span id="cb1-122"><a href="#cb1-122"></a>  )</span>
<span id="cb1-123"><a href="#cb1-123"></a>  </span>
<span id="cb1-124"><a href="#cb1-124"></a>  <span class="fu">ggplot</span>(mle) <span class="sc">+</span></span>
<span id="cb1-125"><a href="#cb1-125"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x =</span> theta1, <span class="at">y =</span> theta2, <span class="at">color =</span> selection)) <span class="sc">+</span></span>
<span id="cb1-126"><a href="#cb1-126"></a>    <span class="fu">geom_point</span>(<span class="at">x =</span> mle[<span class="dv">1</span>, <span class="dv">1</span>], <span class="at">y =</span> mle[<span class="dv">1</span>, <span class="dv">2</span>], <span class="at">shape =</span> <span class="dv">4</span>) <span class="sc">+</span></span>
<span id="cb1-127"><a href="#cb1-127"></a>    <span class="fu">geom_segment</span>(</span>
<span id="cb1-128"><a href="#cb1-128"></a>      <span class="fu">aes</span>(<span class="at">x =</span> X1, <span class="at">y =</span> X2, <span class="at">xend =</span> X3, <span class="at">yend =</span> X4),</span>
<span id="cb1-129"><a href="#cb1-129"></a>      <span class="at">data =</span> zero.seg, <span class="at">color =</span> <span class="st">'black'</span></span>
<span id="cb1-130"><a href="#cb1-130"></a>    ) <span class="sc">+</span></span>
<span id="cb1-131"><a href="#cb1-131"></a>    <span class="fu">geom_segment</span>(</span>
<span id="cb1-132"><a href="#cb1-132"></a>      <span class="fu">aes</span>(<span class="at">x =</span> X1, <span class="at">y =</span> X2, <span class="at">xend =</span> X3, <span class="at">yend =</span> X4),</span>
<span id="cb1-133"><a href="#cb1-133"></a>      <span class="at">data =</span> true.zero.seg, <span class="at">color =</span> <span class="st">'black'</span>,</span>
<span id="cb1-134"><a href="#cb1-134"></a>      <span class="at">linetype =</span> <span class="st">'dashed'</span></span>
<span id="cb1-135"><a href="#cb1-135"></a>    ) <span class="sc">+</span></span>
<span id="cb1-136"><a href="#cb1-136"></a>    <span class="fu">coord_cartesian</span>(</span>
<span id="cb1-137"><a href="#cb1-137"></a>      <span class="at">xlim =</span> <span class="fu">c</span>(<span class="fu">min</span>(mle<span class="sc">$</span>theta1), <span class="fu">max</span>(mle<span class="sc">$</span>theta1)),</span>
<span id="cb1-138"><a href="#cb1-138"></a>      <span class="at">ylim =</span> <span class="fu">c</span>(<span class="fu">min</span>(mle<span class="sc">$</span>theta2), <span class="fu">max</span>(mle<span class="sc">$</span>theta2))</span>
<span id="cb1-139"><a href="#cb1-139"></a>    )</span>
<span id="cb1-140"><a href="#cb1-140"></a>}</span>
<span id="cb1-141"><a href="#cb1-141"></a></span>
<span id="cb1-142"><a href="#cb1-142"></a><span class="fu">GLMSim</span>(</span>
<span id="cb1-143"><a href="#cb1-143"></a>  <span class="at">theta =</span> <span class="fu">c</span>(<span class="fl">0.05</span>, <span class="dv">0</span>), <span class="at">lambda =</span> <span class="fl">0.04</span>, <span class="at">n =</span> <span class="dv">100</span>, <span class="at">nRep =</span> <span class="dv">1000</span>,</span>
<span id="cb1-144"><a href="#cb1-144"></a>  <span class="at">family =</span> <span class="st">'binomial'</span></span>
<span id="cb1-145"><a href="#cb1-145"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="asymptotic-selective-inference_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We then look specifically at the sample marked with <code>x</code>. The approximating the selection event based on the score at zero will approximate the event much better around the origin, but we also care much less about this scenerio. The ‘high stake’ scanerio is when the statistic is close the the boundaries — and in these cases we would want the selection event to be approximated better for that section of the boundary. The MLE thus appeals to this.</p>
<p>The Hessian of the log-likelihood has to be approximated as well. The selection event given by the true Hessian is given as dashed lines above, while the estimated Hessian is given as solid lines. Notice that while the approximation on the left edge of the red region is not done well, the approximation is done well in the bottom edge, which is more important to us. Also notice that the estimated Hessian performs fairly well.</p>
<p>Finally, how is these approximations linked to that of Taylor and Tibshirani (2017)? They used the lasso estimate with one extra Newton step as their test statistic. Assuming the log-likelihood behaves sufficiently quadratic, this is the same as using the MLE. We admit that their approach probably has a slight edge, an MLE would require solving a whole new approximation problem, while a one-extra-Newton-step lasso estimate is extremely easy to compute. In application, we believe these two methods should perform similarly.</p>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-lee2016exact" class="csl-entry" role="listitem">
Lee, J. D., Sun, D. L., Sun, Y., and Taylor, J. E. (2016), <span>“Exact post-selection inference, with application to the lasso,”</span> <em>The Annals of Statistics</em>, 44, 907–927.
</div>
<div id="ref-taylor2017post" class="csl-entry" role="listitem">
Taylor, J. E., and Tibshirani, R. J. (2017), <span>“Post-selection inference for <span><span class="math inline">\(\ell\)</span></span>1-penalized likelihood models,”</span> <em>The Canadian Journal of Statistics</em>, 19, 1212.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/khung\.me");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:me@khung.me">
      <i class="bi bi-envelope-fill" role="img" aria-label="email: me@khung.me">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kenhungkk">
      <i class="bi bi-github" role="img" aria-label="github: kenhungkk">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://scholar.google.com/citations?user=G0x9hZkAAAAJ&amp;hl=en">
      <i class="bi bi-mortarboard-fill" role="img" aria-label="google scholar">
</i> 
    </a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>